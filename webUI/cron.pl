#!/usr/bin/perl

#place in /etc/cron.d
#run by line in /etc/crontab
#TO DO: relative path to location of swls and swChnMsg

use strict;
use warnings;
use Data::Dumper; #cleanly print array, hash

#sw opcodes
my $state = "0x0010";
my $voltage = "0x0020";
my $current = "0x0021";
my $power = "0x0022";
my $freq = "0x0023";
my $phase = "0x0024";
#sw types
my $outlet = "0x8000000000000004";
my $master = "0x8000000000000001";
my $universal = "0x8000000000000000";

chdir("/home/laura/senior/code/SmartWallv1/usermon") or die "$!";

#query for all devices and info
my $outlets_raw = `./swls -raw`; #backtick system call
chomp($outlets_raw);
my @ls_lines = split(/\n/,$outlets_raw); #split on new lines

#fill hash of hashes, %lookup, with device info
my %lookup;
foreach my $row (@ls_lines){
    my @items = split(/ /,$row);
    $items[7] =~ s/ //;
    $lookup{$items[7]}{'swAdr'}=$items[1];
    $lookup{$items[7]}{'ipAdr'}=$items[2];
    $lookup{$items[7]}{'type'}=$items[3];
    $lookup{$items[7]}{'channels'}=$items[4];
    $lookup{$items[7]}{'grpId'}=$items[5];
    $lookup{$items[7]}{'ver'}=$items[6];
}
#print Dumper(%lookup); #debug
#print "$lookup{'0x0000000000000011'}{'swAdr'}\n"; #debug

#for devices of type 'outlet', query for power
foreach my $key (sort keys %lookup) { 
    print "$key"; #debug
    print "\n"; #debug
    my $swAdr;
    my $power_string; #response to power query
    if($lookup{$key}{'type'} eq $outlet) {
	my $channels = $lookup{$key}{'channels'};
	if ($channels eq "0x01") {
	    #one channel device
	    $swAdr = $lookup{$key}{'swAdr'};
	    my $power_query = "./swChnMsg $swAdr QUERY OUTLET $power 1 0 x";
	    print "$power_query\n"; #debug
	    #$power_string = `$power_query`; #backtick system call
	    #chomp($power_string);
	} elsif ($channels eq "0x02") {
	    print "Entered 2-channel loop\n"; #debug
	    #two channel device
	    $swAdr = $lookup{$key}{'swAdr'};
	    my $power_query = "./swChnMsg $swAdr QUERY OUTLET $power 1 0 x 1 x";
	    print "$power_query\n"; #debug
	    #$power_string = `$power_query`; #backtick system call
	    $power_string = `./swChnMsg 0x0011 QUERY OUTLET $state 1 0 x 1 x`; #temporary
	    chomp($power_string);
	    print "Power string is $power_string\n"; #debug
	} else {
	    print "-E-: Invalid number of channels\n";
	    #error or unhandled number of channels
	}
	#deal with $power_string
	if (defined($power_string)) {
	    print "It's defined\n"; #debug
	    if($power_string =~ m/ERROR/) {
		#error generated by Andy's script
	    #} elsif ($power_string =~ m/$swAdr REPORT OUTLET $power 0 (\d+)( 1 (\d+))?$/) {
	    } elsif ($power_string =~ m/0x0011 REPORT OUTLET $state 0 (\d+)( 1 (\d+))?$/) {
		print "Matched regex\n";
		#proper response - parse it
		my $power0, my $power1;
		if($channels eq "0x02"){ 
		    $power0 = $1;
		    $power1 = $3;
		    print "Powers are: $power0, $power1\n"; #debug
		    #write to file
		    my $month = `date "+%m"`; #backtick system call to get month
		    my $year = `date "+%Y"`;
		    chomp($month);
		    chomp($year);
		    my $file_name = '../webUI/historic/'.$key.'_'.$month.'_'.$year;  
		    open(FILE_HANDLE,'>>',"$file_name") or die "-E- Unable to open $file_name : $!\n";
		    print FILE_HANDLE "$power0 $power1\n";
		    close(FILE_HANDLE);
		}else{
		    $power0 = $1;
		    #write to file
		    my $file_name = './historic/'.$key;  
		    open(FILE_HANDLE,'>>',"$file_name") or die "-E- Unable to open $file_name : $!\n";
		    print FILE_HANDLE "$power0\n";
		    close(FILE_HANDLE);
		}
	    } else {
		#some other kind of error
	    }
	} else {
	    #no power_string
	}
    } else {
	print "-W-: Not an outlet.\n";
	#not outlet, handle other types as relevant
    }
    undef($power_string);
}
    
